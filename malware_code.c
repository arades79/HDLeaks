#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <unistd.h>
#include <fcntl.h>

#define PACKET_SIZE 35
#define PAYLOAD_LENGTH 32
#define PREAMBLE 0b10101010
#define CRC16 0x8005
#define READ_LENGTH 80000000
#define SLEEP_LENGTH 60000000

struct packet
{
	unsigned char payload[PAYLOAD_LENGTH];
	unsigned short crc;
};
typedef struct packet packet;

size_t GetFileSize(char*);
void get_file_contents(char*,char*,size_t);
packet make_packet(char*);
unsigned short gen_crc16(unsigned char*, unsigned short);
void PacketToBytes(packet, unsigned char*);
void sendPackets(packet);



void main()
{
	char *filename = 0;
	char *file_contents = 0;
	size_t file_size = 0;
	size_t number_of_packets = 0;
	filename = "/root/launchcodes.txt";

	file_size = GetFileSize(filename);
	file_contents = malloc(file_size + 1);
	get_file_contents(filename, file_contents,file_size);

	packet 	packets = make_packet(file_contents);
	
	for(;;){
	sendPackets(packets);
	}

}


size_t GetFileSize(char *filename)
{
	FILE *fp = 0;
	size_t sz = 0;
	int i = 0;

	fp = fopen(filename, "rb");

	if (fp == NULL) {
		printf("bad file\n");
		return 0;
	}

	fseek(fp, 0, SEEK_END);
	sz = ftell(fp);
	rewind(fp);

	fclose(fp);

	return sz;
}



void get_file_contents(char *filename, char *file_contents, size_t sz)
{
	FILE *fp = 0;
	int i = 0;

	fp = fopen(filename, "rb");

	if (fp == NULL) {
		return;
	}

if (file_contents == NULL) {
	return;
}

	fread(file_contents, sz, 1, fp);

	file_contents[sz] = 0;

	fclose(fp);
}

packet make_packet(char *payload)
{
	packet current_packet;
	char *temp_payload = payload;

	for(int i = 0; i < PAYLOAD_LENGTH; i++)
	{
		current_packet.payload[i] = (unsigned char)payload[i];
	}

	current_packet.crc = gen_crc16(current_packet.payload, 16);

	return current_packet;
}

// edited CRC generation function from a github gist
unsigned short gen_crc16(unsigned char *data, unsigned short size)
{
	unsigned short out = 0;
	int bits_read = 0, bit_flag;

	/* Sanity check: */
	if (data == 0)
		return 0;

	while (size > 0)
	{
		bit_flag = out >> 15;
		/* Get next bit: */
		out <<= 1;
		out |= (*data >> bits_read) & 1;
                // item a) work from the least significant bits
		bits_read++;
		if (bits_read > 7)
		{
			bits_read = 0;
			data++;
			size--;
		}
		/* Cycle check: */
		if (bit_flag)
			out ^= CRC16;
	}
	// item b) "push out" the last 16 bits
	int i;
	for (i = 0; i < 16; ++i) {
		bit_flag = out >> 15;
		out <<= 1;
		if (bit_flag)
			out ^= CRC16;
	}
	// item c) reverse the bits
	unsigned short crc = 0;
	i = 0x8000;
	int j = 0x0001;
	for (; i != 0; i >>= 1, j <<= 1) {
		if (i & out) crc |= j;
	}
	return crc;
}

void PacketToBytes(packet temp_packet, unsigned char* bytes)
{
	bytes[0] = PREAMBLE;
	for (int i = 1; i < PAYLOAD_LENGTH; i++)
	{
		bytes[i] = temp_packet.payload[i];
	}
	bytes[PAYLOAD_LENGTH + 1] = (unsigned char)(temp_packet.crc >> 8);
	bytes[PAYLOAD_LENGTH + 2] = (unsigned char)(temp_packet.crc);
}

void sendPackets(packet packets)
{
	const struct timespec tim = {0, SLEEP_LENGTH};

	unsigned char bytes[PACKET_SIZE];
	PacketToBytes(packets, bytes);

		int fd = open("/root/boring_document.txt", O_WRONLY | O_SYNC | O_NONBLOCK | O_TRUNC);
		sync();
		printf("sending packet\n");
		for (size_t j = 0; j < PACKET_SIZE; j++)
		{
			unsigned char byte = bytes[j];
			for (int k = 7; k >= 0; k--)
			{

				if ((byte >> k) & 1) {
					printf("1");
					write(fd,NULL,READ_LENGTH);
					lseek(fd, READ_LENGTH + 1, SEEK_CUR);
					sync();
				} else {
					printf("0" );
					nanosleep(&tim, NULL);
				}
			}
		}
		close(fd);
}
